# 死信队列

### 消息超时/过期

topic的消息默认不持久化，消费者要比生产者先上线才能接收到消息，没有被消费的消息默认存在内存里，重启后就没有了。

如果是重要的消息消费者没有接收到怎么办？怎么让消息重新投递？消息是有过期时间的，不会长时间存在MQ里，默认的超时时间很长。可以设置消息的超时时间，过期后的消息会进到一个队列里，这个队列叫死信队列。

设置超时时间：





0-15临时节点，在同一个connect有效


21过期后会进到死信队列，设置过期时间

23设置超时时间+死信队列，过期的消息进死信队列，可以拿出来重发
25设置消息超时时间(默认很长)+producer监听死信队列，
两层处理:
从producer层面，监听私信，拿出重发，此处有图。topic和Queue都有死心队列概念，不过是一个是多个消费者一个是一个消费者，topic只要有一个消费者消费到消息就不会进死信队列
mq层面，也可以设置重投次数，类似于quartz的定时，消费者ack过的也投，不管你是否消费过，消费者这需要做幂等
30receive方法是阻塞的，单线程执行，如果消息大，IO也是瓶颈，不支持并发，可能造成消息堆积，receive(时间)，还取不到消息继续往下执行，
43 Listener 其他类型message
48信任的包
57  bytemessage  写入和读取顺序一致否则可能报错
1.01bytemessage读取字符串，写到文件里
1.10mapmessage

文件，不消费，一直在内存里，炸掉
1.27设置消息ttl，死信队列。监听死心队列消费，手动清除
28优先级配置。policyentry漏掉了？
32死信队前缀列名称修改，一个队列对应一个死信队列topic和Queue不一样，
死信队列做消息重投
35，设置持久化模式为不持久话，不持久化的消息不进死信队列，producer.setDeliveryModel DeliveryModel.NotPersitence
不同队列设置进到不同的死信队列？？
36演示非持久化的消息不进死信队列，默认就被消费了，就丢了，马克当，怎么让非持久化的消息进私信
41让非持久化的消息也进死信队列，提高性能，减轻服务端压力不做持久化，设置超时时间，到了，进死信队列。
45对于不重要的消息如日志，持久化的消息，过期不进死信队列。消费者不启动，不过期？启动了私信才过期消失？

47总结:持久化的消息才会进死信队列，非持久化的消息需要改配置才进。可以关闭死信队列提高性能，但是极有可能会丢消息

51两个消费者轮训消费一个队列演示
55独占消费者演示，一直等到独占的下线，别的等待的消费者才能接盘，独占消费者是选择器的一种

2.03消息分组，设置消息头属性，多个消费者，相比独占消费可以提高并发，定向分发，负载均衡
100g配置文件，启动读取系统，不是写多少就用
topic

