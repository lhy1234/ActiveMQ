### 临时目的地

```java
session.createTemporaryQueue();
session.createTemporaryTopic();
```

可以通过会话上的createTemporaryQueue方法和createTemporaryTopic方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保持的时间。只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息。

在消息中间件上创建一个临时节点临时存点东西。

一言以蔽之：

生命周期是一个Connection，如果是同一个Connection就可以访问到这个临时目的地。

隔离特性也是一个Connection，不同的Connection创建出来的session是不能互相访问的。

用途：

带消息确认的同步消息，Producer发一条消息给MQ，Consumer有没有把消息消费掉进行ACK，就是用临时的Destination实现的。



### 消息超时/过期

producer往topic里发消息，consumer还没上线

![1610877533411](D:\Z_lhy\STUDY\ActiveMQ\doc\img\0Active MQ的安全机制.md)

此时数据库里也不会有user的消息

![1610877617664](D:\Z_lhy\STUDY\ActiveMQ\doc\img\1610877617664.png)

topic的消息默认不持久化，消费者要比生产者先上线才能接收到消息，没有被消费的消息默认存在内存里，重启后就没有了。

此时启动consumer，也消费不到这些消息：

![1610877765532](D:\Z_lhy\STUDY\ActiveMQ\doc\img\1610877765532.png)

此时consumer处于while(true)运行状态，让producer再发10条消息，consumer这边就会消费10条消息

![1610877851479](D:\Z_lhy\STUDY\ActiveMQ\doc\img\1610877851479.png)

那么队列里有20条消息，后面的10条被消费，那么之前的10条在服务器内存里，没有做持久化。

那么这10条消息在这里存着没有什么意义了。如果之前producer投放 了一次消息（重要的消息）消费者都没在线，消费者没有接收到怎么办？这时候存着这些消息的意义就是让你知道我这10条消息还没被消费。你需要了我就给你，这里面有个消息过期的机制。这10条消息不会在这这里长期的停留着，默认是永不过期。

#### 设置超时时间

在发送消息的时候，可以设置消息的过期时间，过期后的消息会进到一个队列里，这个队列叫死信队列（DLQ）。

```java
producer.setTimeToLive
```

 设置了消息超时的消息，消费端在超时后无法在消费到此消息。 

 给消息设置一个超时时间 ---> 死信队列 -----> 拿出来 -----> 重发 

#### 死信

此类消息会进入到`ActiveMQ.DLQ`队列且不会自动清除，称为死信

此处有消息堆积的风险



#### 消息重投机制

生产者把消息扔到MQ，此时消费者没上线，消息就在MQ内存里。

消息过期后，进入到死信队列。

producer可以监听死信队列，把死信队列的消息拿出来。

如果MQ内存中的消息没人消费，或者死信队列中的消息没人消费，都会可能消息堆积。

queue/topic都有私信，只不过一个是一个消费者，一个是多个消费者。对于topic，只要有一个订阅者消费消息，消息就不会进入到死信队列。



0-15临时节点，在同一个connect有效


21过期后会进到死信队列，设置过期时间

23设置超时时间+死信队列，过期的消息进死信队列，可以拿出来重发
25设置消息超时时间(默认很长)+producer监听死信队列，
两层处理:
从producer层面，监听私信，拿出重发，此处有图。topic和Queue都有死心队列概念，不过是一个是多个消费者一个是一个消费者，topic只要有一个消费者消费到消息就不会进死信队列
mq层面，也可以设置重投次数，类似于quartz的定时，消费者ack过的也投，不管你是否消费过，消费者这需要做幂等
30receive方法是阻塞的，单线程执行，如果消息大，IO也是瓶颈，不支持并发，可能造成消息堆积，receive(时间)，还取不到消息继续往下执行，
43 Listener 其他类型message
48信任的包
57  bytemessage  写入和读取顺序一致否则可能报错
1.01bytemessage读取字符串，写到文件里
1.10mapmessage

文件，不消费，一直在内存里，炸掉
1.27设置消息ttl，死信队列。监听死心队列消费，手动清除
28优先级配置。policyentry漏掉了？
32死信队前缀列名称修改，一个队列对应一个死信队列topic和Queue不一样，
死信队列做消息重投
35，设置持久化模式为不持久话，不持久化的消息不进死信队列，producer.setDeliveryModel DeliveryModel.NotPersitence
不同队列设置进到不同的死信队列？？
36演示非持久化的消息不进死信队列，默认就被消费了，就丢了，马克当，怎么让非持久化的消息进私信
41让非持久化的消息也进死信队列，提高性能，减轻服务端压力不做持久化，设置超时时间，到了，进死信队列。
45对于不重要的消息如日志，持久化的消息，过期不进死信队列。消费者不启动，不过期？启动了私信才过期消失？

47总结:持久化的消息才会进死信队列，非持久化的消息需要改配置才进。可以关闭死信队列提高性能，但是极有可能会丢消息

51两个消费者轮训消费一个队列演示
55独占消费者演示，一直等到独占的下线，别的等待的消费者才能接盘，独占消费者是选择器的一种

2.03消息分组，设置消息头属性，多个消费者，相比独占消费可以提高并发，定向分发，负载均衡
100g配置文件，启动读取系统，不是写多少就用
topic

